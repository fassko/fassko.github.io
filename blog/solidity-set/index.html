<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/solidity-set"/><meta name="twitter:url" content="https://kristaps.me/blog/solidity-set"/><meta name="og:url" content="https://kristaps.me/blog/solidity-set"/><title>Leveraging the Set Structure in Solidity | Kristaps Grinbergs</title><meta name="twitter:title" content="Leveraging the Set Structure in Solidity | Kristaps Grinbergs"/><meta name="og:title" content="Leveraging the Set Structure in Solidity | Kristaps Grinbergs"/><meta name="description" content="A Set structure, as used in many programming languages, is a collection of distinct elements where each item is unique, and no duplicates are allowed. This data structure is especially valuable when you need to efficiently check the existence of an item, maintain an organized collection of items without repetition, or quickly retrieve unique elements. Solidity programming language for Ethereum smart contract development does not natively support the Set data structure. Developers need to create their own structures or utilize external libraries to replicate Set functionalities, such as ensuring the uniqueness of elements within a collection."/><meta name="twitter:description" content="A Set structure, as used in many programming languages, is a collection of distinct elements where each item is unique, and no duplicates are allowed. This data structure is especially valuable when you need to efficiently check the existence of an item, maintain an organized collection of items without repetition, or quickly retrieve unique elements. Solidity programming language for Ethereum smart contract development does not natively support the Set data structure. Developers need to create their own structures or utilize external libraries to replicate Set functionalities, such as ensuring the uniqueness of elements within a collection."/><meta name="og:description" content="A Set structure, as used in many programming languages, is a collection of distinct elements where each item is unique, and no duplicates are allowed. This data structure is especially valuable when you need to efficiently check the existence of an item, maintain an organized collection of items without repetition, or quickly retrieve unique elements. Solidity programming language for Ethereum smart contract development does not natively support the Set data structure. Developers need to create their own structures or utilize external libraries to replicate Set functionalities, such as ensuring the uniqueness of elements within a collection."/><meta name="og:site_name" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:title" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:image" content="https://kristaps.me/og-image.png"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-HBCE3H3QVL"></script><script src="/scripts/ga.js"></script><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1><a class="blog-title" href="/blog/solidity-set">Leveraging the Set Structure in Solidity</a></h1><div class="blog-date"><ul class="blog-tags"><li><a href="/tags/solidity">Solidity</a></li><li><a href="/tags/web3">web3</a></li><li><a href="/tags/set">set</a></li><li><a href="/tags/nft">nft</a></li></ul>Jul 25, 2023</div><div class="blog-content"><p>A Set structure, as used in many programming languages, is a collection of distinct elements where each item is unique, and no duplicates are allowed. This data structure is especially valuable when you need to efficiently check the existence of an item, maintain an organized collection of items without repetition, or quickly retrieve unique elements. Solidity programming language for Ethereum smart contract development does not natively support the Set data structure. Developers need to create their own structures or utilize external libraries to replicate Set functionalities, such as ensuring the uniqueness of elements within a collection.</p><h2>Functionality of the Set</h2><p>The Set structure we're going to build will have the ability to add items, remove items, check if an item is in the Set, and list all the unique elements.</p><p>In order to implement each of these functionalities, we must first complete some prework by creating two variables to hold set values and their corresponding indexes.</p><pre><code>contract <span class="type">Set</span> {
  uint256[] <span class="keyword">public</span> elements;

  <span class="call">mapping</span>(uint256 =&gt; uint256) <span class="keyword">private</span> indexes;
</code></pre><p>We will use the built-in array structure in Solidity to hold all the elements in the sSt, which will be stored in the variable "items".</p><p>One way to ensure that each element in a set is unique is by using the mapping structure from Solidity. The index of each value in the "items" array will serve as the key, while each element in the Set will have the corresponding value in the mapping structure.</p><h2>Set Operations</h2><p>Let's delve into the functionality of each Set operation.</p><h3>How to Add an Element</h3><p>Adding an element to our Set is an essential feature. We need to ensure that every addition will be checked for uniqueness, and only when the element doesn't already exist in the Set will it be added. This will prevent any duplicates and maintain the integrity of our Set.</p><pre><code>function <span class="call">insert</span>(uint256 value) <span class="keyword">public</span> {
  <span class="keyword">if</span> (indexes[value] == <span class="number">0</span>) {
    elements.<span class="call">push</span>(value);
    indexes[value] = elements.<span class="property">length</span>;
  }
}
</code></pre><p>Let's examine the code. Initially, we should verify if the element is present in the Set. This can be achieved by checking if the <code>indexes</code> mapping has an index for the given element. If it does not, we can add the element to the <code>elements</code> array and establish the index in the <code>indexes</code> mapping.</p><p>It would be wise to extract this element into a separate function as we need to verify its existence in the Set in other areas.</p><pre><code>function <span class="call">contains</span>(uint256 value) <span class="keyword">public</span> view <span class="call">returns</span>(bool) {
  <span class="keyword">return</span> indexes[value] != <span class="number">0</span>;
}
</code></pre><p>We can employ this function in the conditional check. However, a better approach in Solidity is to utilize the <code>require</code> control structure. Thus, let's modify the <code>insert</code> function.</p><pre><code>function <span class="call">insert</span>(uint256 value) <span class="keyword">public</span> {
  <span class="call">require</span>(!<span class="call">contains</span>(value), <span class="string">"Already contains value"</span>);

  elements.<span class="call">push</span>(value);
  indexes[value] = elements.<span class="property">length</span>;
}
</code></pre><p>The code is now simpler to understand and has improved readability.</p><h3>How to Remove an Element</h3><p>The ability to remove elements from our Set gives us flexibility in managing our data. If an element is no longer needed or has become irrelevant, we can remove it from the Set. To maintain efficiency, the removal process should also confirm the existence of an item before attempting its deletion.</p><pre><code>function <span class="call">remove</span>(uint256 value) <span class="keyword">public</span> {
  <span class="call">require</span>(<span class="call">contains</span>(value), <span class="string">"Set does not contain such value"</span>);

  <span class="comment">// find out the index</span>
  uint256 index = indexes[value];

  <span class="comment">// moves last element to the place of the value
  // so there are no free spaces in the array</span>
  uint256 lastValue = elements[elements.<span class="property">length</span> - <span class="number">1</span>];
  elements[index - <span class="number">1</span>] = lastValue;
  indexes[lastValue] = index;

  <span class="comment">// delete the index</span>
  delete indexes[value];

  <span class="comment">// deletes last element and reduces array size</span>
  elements.<span class="call">pop</span>();
}
</code></pre><p>Although this function seems lengthy and complicated, let's review it together.</p><p>First, we check if the element exists in the Set. If it does, we must determine its index from the <code>indexes</code> mapping.</p><p>To remove an element from the "elements" array in Solidity, we should avoid using the "delete" function as it creates empty spaces in the array without altering its length. Instead, we can move the last element of the array to the position of the element we want to remove.</p><p>Finally, we will use the <code>pop</code> built-in function to remove the last element from the array and remove the element index.</p><h3>List all elements in the Set</h3><p>Lastly, we will need a function that lists all the elements in the Set. This feature provides a view of all the unique elements we have collected. Whether we need to debug our code, verify our operations, or use the Set's data, a function to list all elements is invaluable.</p><pre><code>function <span class="call">values</span>() <span class="keyword">public</span> view <span class="call">returns</span>(uint256[] memory) {
  <span class="keyword">return</span> elements;
}
</code></pre><p>The 'elements' array can be returned since the order is insignificant.</p><p>We can include a helper function that will give us the number of elements in the set.</p><pre><code>function <span class="call">length</span>() <span class="keyword">public</span> view <span class="call">returns</span>(uint256) {
  <span class="keyword">return</span> elements.<span class="property">length</span>;
}
</code></pre><p>This function can come in handy if we want to understand if the Set holds anything at all and if we're going to iterate over it ourselves.</p><h2>TL;DR</h2><p>Solidity programming language does not have a built-in Set data structure. However, we can solve this issue by merging two existing Solidity structures - arrays and mappings. This approach enables us to build all the functions of a Set, such as adding unique elements, removing them, checking for their presence, and listing all current elements.</p><h2>Links</h2><ul><li><a href="https://gist.github.com/fassko/ebba36f92106f367db45d09043cb6547">Sample code</a></li></ul><ul><li><a href="https://kristaps.me/blog/solidity-array/">Mastering Arrays in Solidity</a></li><li><a href="https://kristaps.me/blog/solidity-mapping/">The Story behind Mapping in Solidity</a></li><li><a href="https://ethereum.stackexchange.com/questions/69672/std-set-in-solidity">Set in solidity?</a></li><li><a href="https://programtheblockchain.com/posts/2018/06/03/storage-patterns-set/">Storage Patterns: Set</a></li><li><a href="https://github.com/rob-Hitchens/UnorderedKeySet">Unordered Key Set</a></li></ul></div></div></section></div><footer class="footer"><p>Copyright © Kristaps Grinbergs. 2025.</p><p><a href="https://twitter.com/fassko" target="_blank">Twitter</a>•<a href="/feed.rss">RSS</a>•<a href="/about">Contact</a></p></footer></body></html>