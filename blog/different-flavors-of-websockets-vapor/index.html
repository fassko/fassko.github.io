<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/different-flavors-of-websockets-vapor"/><meta name="twitter:url" content="https://kristaps.me/blog/different-flavors-of-websockets-vapor"/><meta name="og:url" content="https://kristaps.me/blog/different-flavors-of-websockets-vapor"/><title>Different flavors of WebSockets on Vapor with Swift | Kristaps Grinbergs</title><meta name="twitter:title" content="Different flavors of WebSockets on Vapor with Swift | Kristaps Grinbergs"/><meta name="og:title" content="Different flavors of WebSockets on Vapor with Swift | Kristaps Grinbergs"/><meta name="description" content="Swift on the server lately is getting more traction despite IBM leaving the club. One of the most popular frameworks out there is Vapor. It is built on top of Apple’s SwiftNIO and written fully in Swift programming language. This time we will look into how to work with WebSockets using Vapor framework. We are going to see how to create a client and server using Vapor’s module WebSocketKit and Vapor framework itself."/><meta name="twitter:description" content="Swift on the server lately is getting more traction despite IBM leaving the club. One of the most popular frameworks out there is Vapor. It is built on top of Apple’s SwiftNIO and written fully in Swift programming language. This time we will look into how to work with WebSockets using Vapor framework. We are going to see how to create a client and server using Vapor’s module WebSocketKit and Vapor framework itself."/><meta name="og:description" content="Swift on the server lately is getting more traction despite IBM leaving the club. One of the most popular frameworks out there is Vapor. It is built on top of Apple’s SwiftNIO and written fully in Swift programming language. This time we will look into how to work with WebSockets using Vapor framework. We are going to see how to create a client and server using Vapor’s module WebSocketKit and Vapor framework itself."/><meta name="og:site_name" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:title" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:image" content="https://kristaps.me/og-image.png"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-HBCE3H3QVL"></script><script src="/scripts/ga.js"></script><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1><a class="blog-title" href="/blog/different-flavors-of-websockets-vapor">Different flavors of WebSockets on Vapor with Swift</a></h1><div class="blog-date"><ul class="blog-tags"><li><a href="/tags/nstimer">nstimer</a></li><li><a href="/tags/cadisplaylink">cadisplaylink</a></li><li><a href="/tags/apple">apple</a></li><li><a href="/tags/ios">ios</a></li></ul>Apr 23, 2020</div><div class="blog-content"><p>Swift on the server lately is getting more traction despite <a href="https://forums.swift.org/t/december-12th-2019/31735">IBM leaving the club</a>. One of the most popular frameworks out there is <a href="https://vapor.codes/">Vapor</a>. It is built on top of Apple’s <a href="https://github.com/apple/swift-nio">SwiftNIO</a> and written fully in Swift programming language.</p><p>This time we will look into how to work with WebSockets using Vapor framework. We are going to see how to create a client and server using Vapor’s module <a href="https://github.com/vapor/websocket-kit">WebSocketKit</a> and Vapor framework itself.</p><h2>WebSocketKit</h2><p><a href="https://github.com/vapor/websocket-kit">WebSocketKit</a> is a WebSocket client library built on SwiftNIO. Vapor framework consists of many smaller modules and this is one of them. WebSocketKit is hiding away SwiftNIO lower-level complexity and nicely abstracting the event loops. Let’s see how can we use it.</p><h3>Client</h3><p>When creating a WebSocket client with WebSocketKit we need to follow a couple of steps. At first, we need to create an event loop group where we can receive the WebSocket events such as receiving a text.</p><pre><code><span class="keyword">var</span> eventLoopGroup = <span class="type">MultiThreadedEventLoopGroup</span>(numberOfThreads: <span class="number">2</span>)
</code></pre><p>After that, we should create a WebSocket promise within the created event loop group. Within the promise, we specify the WebSocket events. In this example, we are sending <code>hello</code> String value and printing out text that we receive back.</p><pre><code><span class="keyword">let</span> port: <span class="type">Int</span> = <span class="number">8080</span>
<span class="keyword">let</span> promise = eventLoopGroup.<span class="call">next</span>().<span class="call">makePromise</span>(of: <span class="type">String</span>.<span class="keyword">self</span>)
<span class="type">WebSocket</span>.<span class="call">connect</span>(to: <span class="string">"ws://localhost:</span>\(port)<span class="string">"</span>, on: eventLoopGroup) { ws <span class="keyword">in</span>
  ws.<span class="call">send</span>(<span class="string">"hello"</span>)
  ws.<span class="call">onText</span> { ws, string <span class="keyword">in</span>
    <span class="call">print</span>(string)
  }
}.<span class="call">cascadeFailure</span>(to: promise)
</code></pre><p>After that, we need to wait for executing events within this promise and event loop group.</p><pre><code><span class="keyword">_</span>  = <span class="keyword">try</span> promise.<span class="property">futureResult</span>.<span class="call">wait</span>()
</code></pre><h3>Server</h3><p>Creating a server with WebSocketKit is a bit more complicated - let’s move step by step.</p><p>Similarly, when creating the client we need to create the event loop group.</p><pre><code><span class="keyword">var</span> eventLoopGroup = <span class="type">MultiThreadedEventLoopGroup</span>(numberOfThreads: <span class="number">2</span>)
</code></pre><p>A <code>GET</code> connection can be transformed into WebSocket connection via upgrade dance. When using this approach, we need to configure that ourselves.</p><pre><code><span class="keyword">let</span> upgradePipelineHandler: (<span class="type">Channel</span>, <span class="type">HTTPRequestHead</span>) -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">Void</span>&gt; = { channel, req <span class="keyword">in</span>
  <span class="type">WebSocket</span>.<span class="call">server</span>(on: channel) { ws <span class="keyword">in</span>
    ws.<span class="call">send</span>(<span class="string">"You have connected to WebSocket"</span>)
    
    ws.<span class="call">onText</span> { ws, string <span class="keyword">in</span>
      <span class="call">print</span>(<span class="string">"received"</span>)
      ws.<span class="call">send</span>(string.<span class="call">trimmingCharacters</span>(in: .<span class="dotAccess">whitespacesAndNewlines</span>).<span class="call">reversed</span>())
    }
    
    ws.<span class="call">onBinary</span> { ws, buffer <span class="keyword">in</span>
      <span class="call">print</span>(buffer)
    }
    
    ws.<span class="property">onClose</span>.<span class="call">whenSuccess</span> { value <span class="keyword">in</span>
      <span class="call">print</span>(<span class="string">"onClose"</span>)
    }
  }
}
</code></pre><p>Now as we have created the WebSocket upgrade pipeline let’s use it. To do that we need to create the promise in which we will receive the events.</p><pre><code><span class="keyword">let</span> promise = eventLoopGroup.<span class="call">next</span>().<span class="call">makePromise</span>(of: <span class="type">String</span>.<span class="keyword">self</span>)

<span class="keyword">let</span> server = <span class="keyword">try</span> <span class="type">ServerBootstrap</span>(group: eventLoopGroup).<span class="call">childChannelInitializer</span> { channel <span class="keyword">in
  let</span> webSocket = <span class="type">NIOWebSocketServerUpgrader</span>(
    shouldUpgrade: { channel, req <span class="keyword">in
      return</span> channel.<span class="property">eventLoop</span>.<span class="call">makeSucceededFuture</span>([:])
  },
    upgradePipelineHandler: upgradePipelineHandler
  )
  
  <span class="keyword">return</span> channel.<span class="property">pipeline</span>.<span class="call">configureHTTPServerPipeline</span>(
    withServerUpgrade: (
      upgraders: [webSocket],
      completionHandler: { ctx <span class="keyword">in</span>
        <span class="comment">// complete</span>
    })
  )
}.<span class="call">bind</span>(host: <span class="string">"localhost"</span>, port: port).<span class="call">wait</span>()
</code></pre><p>To boot up the server we need to start waiting for the events with the freshly created promise and server object.</p><pre><code><span class="keyword">_</span> = <span class="keyword">try</span> promise.<span class="property">futureResult</span>.<span class="call">wait</span>()
<span class="keyword">try</span> server.<span class="call">close</span>(mode: .<span class="dotAccess">all</span>).<span class="call">wait</span>()
</code></pre><p>Now we have a running server using WebSocketKit framework. When a client sends text message we are reversing all the characters. For example when a client sends <code>Hello</code> we are sending back <code>olleH</code>.</p><h2>Vapor app approach</h2><p>All this seems quite complicated, but don’t worry - by using Vapor app approach, all this complexity goes away.</p><h3>Client</h3><p>Creating a client is much easier within Vapor app. You just need to create a new WebSocket instance using an event loop group from <code>app</code> object. Then connect to the network address. Within a closure, you get WebSocket object on which you can register events you want to trigger.</p><pre><code><span class="keyword">let</span> url = <span class="string">"wss://echo.websocket.org"</span>
<span class="keyword">let _</span> = <span class="type">WebSocket</span>.<span class="call">connect</span>(to: url, on: app.<span class="property">eventLoopGroup</span>) { ws <span class="keyword">in</span>
  ws.<span class="call">onText</span> { ws, text <span class="keyword">in</span>
    <span class="call">print</span>(text)
  }
  
  ws.<span class="call">send</span>(<span class="string">"Hello"</span>)
}
</code></pre><p>In this example, client sends <code>Hello</code> to the server once connected and prints out to the console any text that is received.</p><h3>Server</h3><p>When creating a server we need to provide an endpoint where clients can connect to. Then within a closure, we get WebSocket object and request object.</p><p>Similarly, like with the client, we can specify what we want to do when these events are triggered. For instance, once the server receives text it will reverse it and send back.</p><pre><code>app.<span class="call">webSocket</span>(<span class="string">""</span>) { request, ws <span class="keyword">in</span>
  ws.<span class="call">send</span>(<span class="string">"You have been connected to WebSockets"</span>)
  
  ws.<span class="call">onText</span> { ws, string <span class="keyword">in</span>
    ws.<span class="call">send</span>(string.<span class="call">trimmingCharacters</span>(in: .<span class="dotAccess">whitespacesAndNewlines</span>).<span class="call">reversed</span>())
  }
  
  ws.<span class="property">onClose</span>.<span class="call">whenComplete</span> { result <span class="keyword">in
    switch</span> result {
    <span class="keyword">case</span> .<span class="dotAccess">success</span>():
      <span class="call">print</span>(<span class="string">"Closed"</span>)
    <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
      <span class="call">print</span>(<span class="string">"Failed to close connection</span> \(error)<span class="string">"</span>)
    }
  }
}
</code></pre><p>Additional to that we can can react once client disconnects and many <a href="http://api.vapor.codes/websocket/latest/WebSocket/Classes/WebSocket.html">more</a>.</p><h2>TL;DR</h2><p>Swift on the server has gained a lot of popularity especially now since iOS developers can create apps and backend services in the same language.</p><p>Most of the Swift server frameworks are built on top of SwiftNIO framework that gives a very granular way to configure WebSockets.</p><p>Using Vapor tools like WebSocketKit and app framework itself we can ease this complicated process. You can check out the <a href="https://github.com/fassko/vapor-websockets">code samples</a> and start using Swift when you need to deal with WebSockets on the backend.</p><h2>Links</h2><ul><li><a href="https://github.com/vapor/websocket-kit">WebSocketKit on Github</a></li><li><a href="http://api.vapor.codes/websocket/latest/WebSocket/index.html">WebSocketKit documentation</a></li><li><a href="https://github.com/fassko/vapor-websockets">Vapor 4.0 WebSockets documentation</a></li><li><a href="http://api.vapor.codes/websocket/latest/WebSocket/index.html">Vapor WebSockets code samples</a></li><li><a href="https://github.com/apple/swift-nio">SwiftNIO</a></li></ul></div></div></section></div><footer class="footer"><p>Copyright © Kristaps Grinbergs. 2025.</p><p><a href="https://twitter.com/fassko" target="_blank">Twitter</a>•<a href="/feed.rss">RSS</a>•<a href="/about">Contact</a></p></footer></body></html>