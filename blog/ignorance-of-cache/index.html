<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/ignorance-of-cache"/><meta name="twitter:url" content="https://kristaps.me/blog/ignorance-of-cache"/><meta name="og:url" content="https://kristaps.me/blog/ignorance-of-cache"/><title>Ignorance of the URLRequest cache | Kristaps Grinbergs</title><meta name="twitter:title" content="Ignorance of the URLRequest cache | Kristaps Grinbergs"/><meta name="og:title" content="Ignorance of the URLRequest cache | Kristaps Grinbergs"/><meta name="description" content="Caching and invalidating cache is one of the hardest things in computer science [according to](https://martinfowler.com/bliki/TwoHardThings.html) Martin Fowler. Recently I was dealing with cache and invalidating it in three of my applications. I had some serious issues with that and wanted to dig deeper. This time we will discuss  `URLRequest` caching strategies and how to use it in your apps. I will share some of my learnings and problems that I found."/><meta name="twitter:description" content="Caching and invalidating cache is one of the hardest things in computer science [according to](https://martinfowler.com/bliki/TwoHardThings.html) Martin Fowler. Recently I was dealing with cache and invalidating it in three of my applications. I had some serious issues with that and wanted to dig deeper. This time we will discuss  `URLRequest` caching strategies and how to use it in your apps. I will share some of my learnings and problems that I found."/><meta name="og:description" content="Caching and invalidating cache is one of the hardest things in computer science [according to](https://martinfowler.com/bliki/TwoHardThings.html) Martin Fowler. Recently I was dealing with cache and invalidating it in three of my applications. I had some serious issues with that and wanted to dig deeper. This time we will discuss  `URLRequest` caching strategies and how to use it in your apps. I will share some of my learnings and problems that I found."/><meta name="og:site_name" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:title" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:image" content="https://kristaps.me/og-image.png"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-HBCE3H3QVL"></script><script src="/scripts/ga.js"></script><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1><a class="blog-title" href="/blog/ignorance-of-cache">Ignorance of the URLRequest cache</a></h1><div class="blog-date"><ul class="blog-tags"><li><a href="/tags/cache">cache</a></li><li><a href="/tags/apple">apple</a></li><li><a href="/tags/ios">ios</a></li><li><a href="/tags/apollo">apollo</a></li></ul>Jan 18, 2020</div><div class="blog-content"><p>Caching and invalidating cache is one of the hardest things in computer science <a href="https://martinfowler.com/bliki/TwoHardThings.html">according to</a> Martin Fowler.</p><p>Recently I was dealing with cache and invalidating it in three of my applications. I had some serious issues with that and wanted to dig deeper. This time we will discuss <code>URLRequest</code> caching strategies and how to use it in your apps. I will share some of my learnings and problems that I found.</p><h2>Creating URLRequest with cache</h2><p>Not so many of us use caching strategy when creating <code>URLRequest</code> and hitting the network. If the server you’re accessing doesn’t have caching strategy implemented then making network requests can cause data corruption in your apps.</p><p>I had these issues with just a simple request and getting new <code>JSON</code> data from the network. For some reason, <code>URLRequest</code> thought that nothing has changed and returned data from internal app cache rather than the network.</p><p>The reason for this is that <code>NSURLCache</code> is set for the application by default according to the <a href="https://developer.apple.com/documentation/foundation/urlcache#//apple_ref/occ/clm/NSURLCache/setSharedURLCache:">documentation</a>. The cache will be purged when the device runs low on disk space, but mostly this isn’t the case. You can control <code>NSURLCache</code> behavior when launching the app but let’s leave that for another post.</p><h2>Caching strategies</h2><p><code>NSURLRequest</code> has a <a href="https://developer.apple.com/documentation/foundation/nsurlrequest/1407944-cachepolicy">property</a> <code>cachePolicy</code> which sets the caching strategy for the request you’re creating. It is an enum and has several <a href="https://developer.apple.com/documentation/foundation/nsurlrequest/cachepolicy">choices</a> defined as constants:</p><ul><li><code>case useProtocolCachePolicy</code> &gt; Use the caching logic defined in the protocol implementation, if any, for a particular URL load request.</li><li><code>case reloadIgnoringLocalCacheData</code> &gt; The URL load should be loaded only from the originating source.</li><li><code>case reloadIgnoringLocalAndRemoteCacheData</code> &gt; Ignore local cache data, and instruct proxies and other intermediates to disregard their caches so far as the protocol allows.</li><li><code>static var reloadIgnoringCacheData: NSURLRequest.CachePolicy</code> &gt; Replaced by NSURLRequest.CachePolicy.reloadIgnoringLocalCacheData</li><li><code>case returnCacheDataElseLoad</code> &gt; Use existing cache data, regardless of age or expiration date, loading from originating source only if there is no cached data.</li><li><code>case returnCacheDataDontLoad</code> &gt; Use existing cache data, regardless of age or expiration date, and fail if no cached data is available.</li><li><code>case reloadRevalidatingCacheData</code> &gt; Use cache data if the origin source can validate it; otherwise, load from the origin</li></ul><p>If you just read the documentation then all of these constants look confusing and hard to choose the right now. Let’s try to understand which of the caching policy you need to choose for your <code>URLRequest</code> and when.</p><h2>Which one to choose?</h2><p>The default policy for URL load requests is <code>useProtocolCachePolicy</code>. If a cached response does not exist then it is fetched from the originating source. Otherwise, if a response doesn’t tell to revalidate then a response is returned from the cache. For more detailed information you can go to <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13">RFC 2616 detailed documentation</a>. Here is an image to illustrate how this policy works.</p><img src="/assets/img/cache/cache-determination.png" alt="How useProtocolCachePolicy works"/><p>Option <code>reloadIgnoringLocalCacheData</code> ignores the local cache and <code>reloadIgnoringLocalAndRemoteCacheData</code> ignores local and remote cache.</p><p>With <code>returnCacheDataElseLoad</code> you tell to use cache no matter how out of date it is. If the cached request doesn’t exist it will be loaded from the network.</p><p>Option <code>returnCacheDataDontLoad</code> is the most confusion one. It means offline mode. Only cached data will be used and it won’t load from the network.</p><p>But the story doesn’t end here, if we check <code>reloadRevalidatingCacheData</code> <a href="https://developer.apple.com/documentation/foundation/nsurlrequest/cachepolicy/reloadrevalidatingcachedata">documentation</a> then we see that previous versions than macOS 15, iOS 13, watchOS 6, and tvOS 13 don’t implement this constant. <a href="https://twitter.com/mattt">Mattt</a> was <a href="https://nshipster.com/nsurlcache/">warning</a> us about that years ago. There is a <a href="http://openradar.appspot.com/radar?id=1755401">radar</a> opened in May 2012.</p><p>So which one to choose? There isn’t a right or wrong answer, but the rule of thumb is - if you want partial cache with default settings then choose <code>useProtocolCachePolicy</code>. If you want to load a request without cache then choose either <code>reloadIgnoringLocalCacheData</code> or <code>reloadIgnoringLocalAndRemoteCacheData</code>.</p><h2>TL;DR</h2><p>Handling cache and cache invalidation are one of the hardest topics in Computer Science. In iOS, macOS, tvOS and watchOS it isn’t easy and straight forward. The official documentation is confusing and isn’t clear how it works behind the scenes.</p><p><code>URLRequest</code> has a <a href="https://developer.apple.com/documentation/foundation/nsurlrequest/1407944-cachepolicy">property</a> <code>cachePolicy</code> which sets the caching strategy for the request.</p><p>For most of the cases default <code>useProtocolCachePolicy</code> option is what you want. If you want to avoid cache then one of <code>reloadIgnoringLocalCacheData</code> or <code>reloadIgnoringLocalAndRemoteCacheData</code> is the right one you have to choose.</p><h2>Links</h2><ul><li><a href="https://developer.apple.com/documentation/foundation/nsurlrequest/cachepolicy">URLRequest Cache Policy documentation</a></li><li><a href="https://nshipster.com/nsurlcache">Article about NSURLCache by NSHipster</a></li><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13">Caching in HTTP</a></li><li><a href="https://www.fabernovel.com/en/engineering/how-to-leverage-http-cache-in-ios">How to leverage HTTP cache in iOS</a></li><li><a href="https://codewithchris.com/preventing-nsurlconnection-cache-issues/">Preventing NSURLConnection Cache Issues</a></li></ul></div></div></section></div><footer class="footer"><p>Copyright © Kristaps Grinbergs. 2025.</p><p><a href="https://twitter.com/fassko" target="_blank">Twitter</a>•<a href="/feed.rss">RSS</a>•<a href="/about">Contact</a></p></footer></body></html>