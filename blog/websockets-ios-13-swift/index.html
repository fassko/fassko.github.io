<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/websockets-ios-13-swift"/><meta name="twitter:url" content="https://kristaps.me/blog/websockets-ios-13-swift"/><meta name="og:url" content="https://kristaps.me/blog/websockets-ios-13-swift"/><title>Websockets in iOS 13 using Swift and Xcode 11 | Kristaps Grinbergs</title><meta name="twitter:title" content="Websockets in iOS 13 using Swift and Xcode 11 | Kristaps Grinbergs"/><meta name="og:title" content="Websockets in iOS 13 using Swift and Xcode 11 | Kristaps Grinbergs"/><meta name="description" content="Websockets in iOS 13, macOS 10.15, tvOS 13, watchOS 6 and Mac Catalyst have gained first-class citizen status in networking stack. Apple has finally added support in [URLSession](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) and for lower level in [Network.framework](https://developer.apple.com/documentation/network/nwprotocolwebsocket) for their platforms. This time we will focus on implementing Websockets using URLSession capabilities."/><meta name="twitter:description" content="Websockets in iOS 13, macOS 10.15, tvOS 13, watchOS 6 and Mac Catalyst have gained first-class citizen status in networking stack. Apple has finally added support in [URLSession](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) and for lower level in [Network.framework](https://developer.apple.com/documentation/network/nwprotocolwebsocket) for their platforms. This time we will focus on implementing Websockets using URLSession capabilities."/><meta name="og:description" content="Websockets in iOS 13, macOS 10.15, tvOS 13, watchOS 6 and Mac Catalyst have gained first-class citizen status in networking stack. Apple has finally added support in [URLSession](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) and for lower level in [Network.framework](https://developer.apple.com/documentation/network/nwprotocolwebsocket) for their platforms. This time we will focus on implementing Websockets using URLSession capabilities."/><meta name="og:site_name" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:title" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:image" content="https://kristaps.me/og-image.png"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-HBCE3H3QVL"></script><script src="/scripts/ga.js"></script><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1><a class="blog-title" href="/blog/websockets-ios-13-swift">Websockets in iOS 13 using Swift and Xcode 11</a></h1><div class="blog-date"><ul class="blog-tags"><li><a href="/tags/swift">swift</a></li><li><a href="/tags/apple">apple</a></li><li><a href="/tags/websockets">websockets</a></li><li><a href="/tags/ios">ios</a></li><li><a href="/tags/xcode">xcode</a></li></ul>Jul 24, 2019</div><div class="blog-content"><p>Websockets in iOS 13, macOS 10.15, tvOS 13, watchOS 6 and Mac Catalyst have gained first-class citizen status in networking stack. Apple has finally added support in <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask">URLSession</a> and for lower level in <a href="https://developer.apple.com/documentation/network/nwprotocolwebsocket">Network.framework</a> for their platforms.</p><p>This time we will focus on implementing Websockets using URLSession capabilities.</p><h2>Before iOS 13</h2><p>Previosly if you wanted to use Websockets in Apple platforms you had to rely on <a href="https://developer.apple.com/documentation/cfnetwork">CFNetwork</a> which was added in iOS 2.0. It is using C based foundation streams. You then have to deal with pointers and memory allocation issues which is quite common in C language.</p><p>Another way was to use third party solutions like <a href="https://github.com/daltoniam/Starscream">Starscream</a> which I have <a href="/websockets-swift/">described before</a>.</p><h2>Websockets using URLSession</h2><p>Here are three ways how you can construct a Websocket using <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask">URLSessionWebSocketTask</a> class provided by <a href="https://developer.apple.com/documentation/foundation/urlsession">URLSession</a>:</p><pre><code><span class="keyword">func</span> webSocketTask(with: <span class="type">URL</span>) -&gt; <span class="type">URLSessionWebSocketTask</span>
<span class="keyword">func</span> webSocketTask(with: <span class="type">URLRequest</span>) -&gt; <span class="type">URLSessionWebSocketTask</span>
<span class="keyword">func</span> webSocketTask(with: <span class="type">URL</span>, protocols: [<span class="type">String</span>]) -&gt; <span class="type">URLSessionWebSocketTask</span>
</code></pre><h3>Opening connection</h3><p>To create and open Websocket connection:</p><pre><code><span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: .<span class="dotAccess">default</span>)
<span class="keyword">let</span> webSocketTask = urlSession.<span class="call">webSocketTask</span>(with: <span class="string">"wss://echo.websocket.org"</span>)
webSocketTask.<span class="call">resume</span>()
</code></pre><h3>Sending messages</h3><p>When connection has been established you can send <code>Data</code> or <code>String</code> message using <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3281790-send">URLSessionWebSocketTask.send</a> function. You need to construct message with <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/message">URLSessionWebSocketTask.Message</a> enum type.</p><pre><code><span class="keyword">let</span> message = <span class="type">URLSessionWebSocketTask</span>.<span class="type">Message</span>.<span class="call">string</span>(<span class="string">"Hello World"</span>)
webSocketTask.<span class="call">send</span>(message) { error <span class="keyword">in
  if let</span> error = error {                
    <span class="call">print</span>(<span class="string">"WebSocket couldnâ€™t send message because:</span> \(error)<span class="string">"</span>)
  }
}
</code></pre><h3>Receiving messages</h3><p>To receive messages from the server you need to use <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3281789-receive">URLSessionWebSocketTask.receive</a> method. It accepts completion handler which is a <a href="https://developer.apple.com/documentation/swift/result">Result</a> of <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/message">Message</a> type.</p><pre><code>webSocketTask.<span class="call">receive</span> { result <span class="keyword">in
  switch</span> result {
  <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
    <span class="call">print</span>(<span class="string">"Error in receiving message:</span> \(error)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> message):
    <span class="keyword">switch</span> message {
    <span class="keyword">case</span> .<span class="dotAccess">string</span>(<span class="keyword">let</span> text):
      <span class="call">print</span>(<span class="string">"Received string:</span> \(text)<span class="string">"</span>)
    <span class="keyword">case</span> .<span class="dotAccess">data</span>(<span class="keyword">let</span> data):
      <span class="call">print</span>(<span class="string">"Received data:</span> \(data)<span class="string">"</span>)
    }
  }
}
</code></pre><p>Be aware that if you want to receive messages continuously you need to call this again once you are done with receiving a message. One way is to wrap this in a function and call the same function recursively.</p><pre><code><span class="keyword">func</span> receiveMessage() {
  webSocketTask.<span class="call">receive</span> { result <span class="keyword">in
    switch</span> result {
    <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
      <span class="call">print</span>(<span class="string">"Error in receiving message:</span> \(error)<span class="string">"</span>)
    <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> message):
      <span class="keyword">switch</span> message {
      <span class="keyword">case</span> .<span class="dotAccess">string</span>(<span class="keyword">let</span> text):
        <span class="call">print</span>(<span class="string">"Received string:</span> \(text)<span class="string">"</span>)
      <span class="keyword">case</span> .<span class="dotAccess">data</span>(<span class="keyword">let</span> data):
        <span class="call">print</span>(<span class="string">"Received data:</span> \(data)<span class="string">"</span>)
      }
      
      <span class="keyword">self</span>.<span class="call">receiveMessage</span>()                
    }
  }	
}
</code></pre><h3>Pings and pongs</h3><p>To keep connection active with the server it is a good approach to send PING message with an interval. You can achieve that with <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3181206-sendping">URLSessionWebSocketTask.sendPing</a> function.</p><pre><code><span class="keyword">func</span> sendPing() {
  webSocketTask.<span class="call">sendPing</span> { (error) <span class="keyword">in
    if let</span> error = error {
      <span class="call">print</span>(<span class="string">"Sending PING failed:</span> \(error)<span class="string">"</span>)
    }

    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: .<span class="call">now</span>() + <span class="number">10</span>) {
      <span class="keyword">self</span>.<span class="call">sendPing</span>()
    }
  }
}
</code></pre><p>Here again you need to take care of the next PING sending yourself. Easiest way is to just use DispatchQueue or Timer functionality.</p><h3>Close connection</h3><p>Once youâ€™re done and would like to close the Websocket connection you need to send a close code which is a <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/closecode">URLSessionWebSocketTask.CloseCode</a> enum type.</p><pre><code>webSocketTask.<span class="call">cancel</span>(closeCode: .<span class="dotAccess">goingAway</span>, reason: <span class="keyword">nil</span>)
</code></pre><h3>Checking connection state</h3><p>To monitor connection status you can use <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsocketdelegate">URLSessionWebSocketDelegate</a> protocol. You can check once connection has been opened or closed.</p><pre><code><span class="comment">/// connection disconnected</span>
<span class="keyword">func</span> urlSession(<span class="keyword">_</span> session: <span class="type">URLSession</span>, 
                webSocketTask: <span class="type">URLSessionWebSocketTask</span>,
                didCloseWith closeCode: <span class="type">URLSessionWebSocketTask</span>.<span class="type">CloseCode</span>,
                reason: <span class="type">Data</span>?)

<span class="comment">// connection established</span>
<span class="keyword">func</span> urlSession(<span class="keyword">_</span> session: <span class="type">URLSession</span>,
                webSocketTask: <span class="type">URLSessionWebSocketTask</span>,
                didOpenWithProtocol protocol: <span class="type">String</span>?)
</code></pre><h2>TL;DR</h2><p>Apple has finally added Websockets as first-class citzen to its platforms. Of course there are small quirks and rough edges. For instance, you canâ€™t receive messages continously, but you donâ€™t need to mess with constructing Websocket frame anymore which is a big win.</p><p>Right now it is available only for latest betas and if you support older versions of iOS, tvOS, watchOS or macOS you need to think about backwards compatibility yourself.</p><h2>Links</h2><ul><li><a href="https://developer.apple.com/documentation/foundation">URLsession documentation</a></li><li><a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask">URLSessionWebSocketTask documentation</a></li><li><a href="https://developer.apple.com/documentation/foundation/urlsessionwebsocketdelegate">URLSessionWebSocketDelegate documentation</a></li><li><a href="https://appspector.com/blog/websockets-in-ios-using-urlsessionwebsockettask">Blogpost by AppSpector</a></li><li><a href="/websockets-swift/">My previous blogpost about using Websockets</a></li></ul></div></div></section></div><footer class="footer"><p>Copyright Â© Kristaps Grinbergs. 2025.</p><p><a href="https://twitter.com/fassko" target="_blank">Twitter</a>â€¢<a href="/feed.rss">RSS</a>â€¢<a href="/about">Contact</a></p></footer></body></html>