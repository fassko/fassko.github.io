<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/solidity-storage-vs-memory"/><meta name="twitter:url" content="https://kristaps.me/blog/solidity-storage-vs-memory"/><meta name="og:url" content="https://kristaps.me/blog/solidity-storage-vs-memory"/><title>Storage and memory secrets in Solidity | Kristaps Grinbergs</title><meta name="twitter:title" content="Storage and memory secrets in Solidity | Kristaps Grinbergs"/><meta name="og:title" content="Storage and memory secrets in Solidity | Kristaps Grinbergs"/><meta name="description" content="This time, we will talk about storage locations in Solidity programming language, specifically about the `storage` and `memory` locations. Not knowing what they represent and how they work can cause issues in our smart contracts."/><meta name="twitter:description" content="This time, we will talk about storage locations in Solidity programming language, specifically about the `storage` and `memory` locations. Not knowing what they represent and how they work can cause issues in our smart contracts."/><meta name="og:description" content="This time, we will talk about storage locations in Solidity programming language, specifically about the `storage` and `memory` locations. Not knowing what they represent and how they work can cause issues in our smart contracts."/><meta name="og:site_name" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:title" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:image" content="https://kristaps.me/og-image.png"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-HBCE3H3QVL"></script><script src="/scripts/ga.js"></script><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1><a class="blog-title" href="/blog/solidity-storage-vs-memory">Storage and memory secrets in Solidity</a></h1><div class="blog-date"><ul class="blog-tags"><li><a href="/tags/solidity">Solidity</a></li><li><a href="/tags/web3">web3</a></li><li><a href="/tags/memory">memory</a></li><li><a href="/tags/storage">storage</a></li></ul>Jun 20, 2022</div><div class="blog-content"><p>This time, we will talk about storage locations in Solidity programming language, specifically about the <code>storage</code> and <code>memory</code> locations. Not knowing what they represent and how they work can cause issues in our smart contracts.</p><h2>Storage</h2><p>Storage in smart contracts holds data between function calls. We can imagine that <code>storage</code> would be as a hard drive in the computer. Even if we turn it off, the data stays and isn't erased. On the blockchain, what we write in storage is stored.</p><h3>Storage by default</h3><h4>State variables</h4><p>By default, Solidity will keep in storage smart contract's state variables.</p><pre><code>contract <span class="type">StorageContract</span> {
  <span class="keyword">struct</span> LuckyNumber {
    uint256 number;
    string reason;
  }

  <span class="call">mapping</span>(address =&gt; <span class="type">LuckyNumber</span>) luckyNumbers;
}
</code></pre><p>In this example smart contract's state variables <code>luckyNumbers</code> are kept in storage, and data will persist between function calls.</p><p>When we add and get the lucky number, we have a predictable outcome.</p><pre><code>function <span class="call">addLuckyNumber</span>(<span class="type">LuckyNumber</span> memory luckyNumber) <span class="call">external</span> {
  <span class="call">require</span>(luckyNumber.<span class="property">number</span> != <span class="number">0</span>, <span class="string">"Lucky number can't be 0!"</span>);
  <span class="call">require</span>(luckyNumbers[msg.<span class="property">sender</span>].number == <span class="number">0</span>, <span class="string">"You already have set lucky number. Edit it if you have another one."</span>);

  luckyNumbers[msg.<span class="property">sender</span>] = luckyNumber;
}

function <span class="call">getMyLuckyNumber</span>() external view <span class="call">returns</span>(uint256) {
  <span class="call">require</span>(luckyNumbers[msg.<span class="property">sender</span>].number != <span class="number">0</span>, <span class="string">"You don't have a lucky number set yet."</span>);

  <span class="type">LuckyNumber</span> memory luckyNumber = luckyNumbers[msg.<span class="property">sender</span>];

  <span class="keyword">return</span> luckyNumber.<span class="property">number</span>;
}
</code></pre><h4>Local function variables</h4><p>Local function variables of struct, array, or mapping are saved in storage by default. It means that if we declare these values in our functions, they are kept in storage, which can cause unexpected issues that are hard to track.</p><p>If we add a function <code>editLuckyNumber</code> to our code example and mark a local copy as <code>storage</code> it will edit the state variable that we expect.</p><pre><code>function <span class="call">editLuckyNumber</span>(uint256 luckyNumber) <span class="call">external</span> {
  <span class="call">require</span>(luckyNumber != <span class="number">0</span>, <span class="string">"Lucky number can't be 0!"</span>);
  <span class="call">require</span>(luckyNumbers[msg.<span class="property">sender</span>].number != <span class="number">0</span>, <span class="string">"You don't have a lucky number set yet."</span>);

  <span class="type">LuckyNumber</span> storage _luckyNumber = luckyNumbers[msg.<span class="property">sender</span>];
  _luckyNumber.<span class="property">number</span> = luckyNumber;
}
</code></pre><h2>Memory</h2><p>In memory, Solidity keeps all locally defined value types, which can be uint, string, etc., but not an array, a struct, or a mapping. Function arguments are kept in memory as well. Remember that <code>memory</code> can't be used at the smart contract level, only locally in functions.</p><pre><code>function <span class="call">multiplyByItself</span>(uint256 number) external pure <span class="call">returns</span>(uint256) {
  uint256 result = number * number;

  <span class="keyword">return</span> result;
}
</code></pre><p>In this example, the function argument <code>number</code> that we pass in our function is stored in memory. Also, locally defined variable of the <code>result</code> is stored in memory and will be released as soon as the function's execution ends.</p><h2>Pitfall using memory and storage</h2><p>One of the major pitfalls of wrong usage of the <code>storage</code> and <code>memory</code> keywords in the Solidity programming language is that we declare a variable either <code>storage</code> or <code>memory</code> without thinking it through. First, keeping data in <code>storage</code> will consume more gas because we need to pay for the block space. Second, we should ask ourselves whether we need to access data that we keep between the function calls. By function calls, there can be even two different functions.</p><p>If we define the <code>_luckyNumber</code> in function <code>editLuckyNumber</code> using the <code>memory</code> keyword, it will edit this function locally only, and changes won't be written to the blockchain.</p><pre><code>function <span class="call">editLuckyNumber</span>(uint256 luckyNumber) <span class="call">external</span> {
  <span class="call">require</span>(luckyNumber != <span class="number">0</span>, <span class="string">"Lucky number can't be 0!"</span>);
  <span class="call">require</span>(luckyNumbers[msg.<span class="property">sender</span>].number != <span class="number">0</span>, <span class="string">"You don't have a lucky number set yet."</span>);

  <span class="type">LuckyNumber</span> memory _luckyNumber = luckyNumbers[msg.<span class="property">sender</span>];
  _luckyNumber.<span class="property">number</span> = luckyNumber;
}
</code></pre><p>This function's outcome will result in editing the lucky number not working because we update it only locally.</p><h2>TL;DR</h2><p>Storing data using Solidity language in our smart contracts is a crucial thing. Life is easier with value types, but with arrays, structs, and mappings, it is more tricky. That's why it is essential to ask whenever we want to save these variables. Do we want data to persist between calling the smart contract or being saved locally while executing the function?</p><h2>Links</h2><ul><li><a href="https://gist.github.com/fassko/5b19bee0c78e3e41aa5d52573b2e696e">Sample code</a></li></ul><ul><li><a href="https://docs.soliditylang.org/en/v0.3.3/frequently-asked-questions.html#what-is-the-memory-keyword-what-does-it-do">What is the memory keyword? What does it do?</a></li><li><a href="https://www.geeksforgeeks.org/storage-vs-memory-in-solidity/">Storage vs Memory in Solidity</a></li><li><a href="https://stackoverflow.com/questions/33839154/in-ethereum-solidity-what-is-the-purpose-of-the-memory-keyword">In Ethereum Solidity, what is the purpose of the "memory" keyword?</a></li></ul></div></div></section></div><footer class="footer"><p>Copyright © Kristaps Grinbergs. 2025.</p><p><a href="https://twitter.com/fassko" target="_blank">Twitter</a>•<a href="/feed.rss">RSS</a>•<a href="/about">Contact</a></p></footer></body></html>