<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/solidity-eip-712-sign-ethers-js"/><meta name="twitter:url" content="https://kristaps.me/blog/solidity-eip-712-sign-ethers-js"/><meta name="og:url" content="https://kristaps.me/blog/solidity-eip-712-sign-ethers-js"/><title>Understanding the Signing Process of Solidity Transactions with Ethers.js | Kristaps Grinbergs</title><meta name="twitter:title" content="Understanding the Signing Process of Solidity Transactions with Ethers.js | Kristaps Grinbergs"/><meta name="og:title" content="Understanding the Signing Process of Solidity Transactions with Ethers.js | Kristaps Grinbergs"/><meta name="description" content="In the previous [post](/blog/solidity-eip-712-sign-metamask/), we discussed meta transactions and the EIP-712 standard. This time we will check out how to sign the transaction with Ethers.js library and execute it in a smart contract. That means that the gas fee will be paid by someone else."/><meta name="twitter:description" content="In the previous [post](/blog/solidity-eip-712-sign-metamask/), we discussed meta transactions and the EIP-712 standard. This time we will check out how to sign the transaction with Ethers.js library and execute it in a smart contract. That means that the gas fee will be paid by someone else."/><meta name="og:description" content="In the previous [post](/blog/solidity-eip-712-sign-metamask/), we discussed meta transactions and the EIP-712 standard. This time we will check out how to sign the transaction with Ethers.js library and execute it in a smart contract. That means that the gas fee will be paid by someone else."/><meta name="og:site_name" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:title" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:image" content="https://kristaps.me/og-image.png"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-HBCE3H3QVL"></script><script src="/scripts/ga.js"></script><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1><a class="blog-title" href="/blog/solidity-eip-712-sign-ethers-js">Understanding the Signing Process of Solidity Transactions with Ethers.js</a></h1><div class="blog-date"><ul class="blog-tags"><li><a href="/tags/solidity">Solidity</a></li><li><a href="/tags/web3">web3</a></li><li><a href="/tags/ethersjs">ethersjs</a></li></ul>Feb 27, 2023</div><div class="blog-content"><p>In the previous <a href="/blog/solidity-eip-712-sign-metamask/">post</a>, we discussed meta transactions and the EIP-712 standard. This time we will check out how to sign the transaction with Ethers.js library and execute it in a smart contract. That means that the gas fee will be paid by someone else.</p><h2>Package up the transaction</h2><p>At first, we need to create a transaction and package it up with all the required components according to the EIP-712 standard. We need three main parts:</p><ul><li>define used types in the message;</li><li>domain information to verify the transaction in the smart contract;</li><li>transaction message that holds the data.</li></ul><h3>Create an unsigned transaction</h3><p>To create an unsigned transaction when calling a smart contract function, we need to use the <code>populateTransaction</code> <a href="https://docs.ethers.org/v5/api/contract/contract/#contract-populateTransaction">function</a> from the EthersJS library. It returns an unsigned transaction that must be signed and submitted to the blockchain network.</p><p>Let's have a smart contract function that will set the current employee.</p><pre><code><span class="keyword">struct</span> EmployeeData {
  uint256 employeeId;
  string employeeName;
}

<span class="type">EmployeeData</span> <span class="keyword">private</span> currentEmployee;
  
function <span class="call">set</span>(uint256 id, string memory name) <span class="call">external</span> {
  currentEmployee = <span class="type">EmployeeData</span>(id, name);
}
</code></pre><p>When creating the transaction, we need to provide all the function parameters and execute it.</p><pre><code>const transaction = <span class="keyword">await</span> employee.<span class="property">populateTransaction</span>.<span class="call">set</span>(<span class="number">1</span>, '<span class="type">John</span>');
</code></pre><p>It will return a transaction object that contains data which is a function signature, <code>from</code> address, <code>to</code> smart contract address and gas limit. We are primarily interested in the function signature that is a hex value. In the beginning, is the hashed function name followed by all the parameter values.</p><pre><code>{
  data: '0x64371977...<span class="number">00</span>',
  to: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
  from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
  gasLimit: <span class="type">BigNumber</span> { value: <span class="string">"29022232"</span> }
}
</code></pre><h3>Putting together the message</h3><p>Let's start with the types object, which has only three parts:</p><ul><li>nonce to avoid duplicate transactions;</li><li>from the address that is the signer of the transaction;</li><li>function signature, which we already create.</li></ul><pre><code>const types = {
  <span class="string">"MetaTransaction"</span>: [
    {
      <span class="string">"name"</span>: <span class="string">"nonce"</span>,
      <span class="string">"type"</span>: <span class="string">"uint256"</span>
    },
    {
      <span class="string">"name"</span>: <span class="string">"from"</span>,
      <span class="string">"type"</span>: <span class="string">"address"</span>
    },
    {
      <span class="string">"name"</span>: <span class="string">"functionSignature"</span>,
      <span class="string">"type"</span>: <span class="string">"bytes"</span>
    }
  ]
};
</code></pre><p>Next is the domain object, which has several parts defined:</p><ul><li>name of the domain to differ transaction in another smart contract;</li><li>the EIP-712 standard version, which in our case will be 1;</li><li>verifying smart contract address that we can get from the unsigned transaction;</li><li><code>salt</code> is the chain id hex value padded with <code>0</code> until its length is 64 chars and starts with <code>0x</code>.</li></ul><pre><code>const salt = ethers.<span class="property">utils</span>.<span class="call">hexZeroPad</span>(ethers.<span class="property">utils</span>.<span class="call">hexValue</span>(network.<span class="property">config</span>.<span class="property">chainId</span> ?? <span class="number">0</span>), <span class="number">32</span>);

const domain = {
  name: <span class="string">"Employee"</span>,
  version: <span class="string">"1"</span>,
  verifyingContract: transaction.<span class="property">to</span>,
  salt: salt
};
</code></pre><p>Finally, we can create the message object, but first, we need to get the nonce from the blockchain smart contract. To do that, we need to pass in the signer's address. By using a nonce, we are avoiding a situation of duplicate transactions.</p><pre><code>const nonce = <span class="keyword">await</span> employee.<span class="call">getNonce</span>(signer.<span class="property">address</span>);
</code></pre><p>The message object has three parts:</p><ul><li>the nonce that is provided by the smart contract;</li><li><code>from</code> address which is the signer address;</li><li>function signature that we got previously from the unsigned transaction.</li></ul><pre><code>const message = {
  <span class="string">"nonce"</span>: nonce,
  <span class="string">"from"</span>: signer.<span class="property">address</span>,
  <span class="string">"functionSignature"</span>: transaction.<span class="property">data</span> ?? ''
};
</code></pre><h2>Sign the transaction</h2><p>We can sign the transaction now that we have all the needed parts defined in the EIP-712 standard, which describes how types are structured and hashed.</p><p>The Ethers.js library has a function <code>_signTypedData</code> that signs the data according to the EIP-712 specification. It is still an experimental function and will be renamed without the underscore, but many projects are using it in production already.</p><pre><code>const signature = <span class="keyword">await</span> signer.<span class="call">_signTypedData</span>(domain, types, message);
</code></pre><h3>Verify the signature</h3><p>As a result, we get a hashed signature from which we can get the signer and see that it is correct. The Ethers.js library has a utility function, <code>verifyTypedData</code> that verifies the transaction data and signature. In return, we get the signer wallet address.</p><pre><code>const signerAddress = ethers.<span class="property">utils</span>.<span class="call">verifyTypedData</span>(
  domain,
  types,
  message,
  signature
);
</code></pre><p>We have signed the transaction, and it is ready to be sent to the blockchain and executed by another wallet holder. That means our users don't need to pay the gas fees, but we can pay and execute transaction behalf of them. We will look at how to do that in one of the upcoming posts.</p><h2>TL;DR</h2><p>Signing a transaction according to the EIP-712 standard with the Ethers JS library is straightforward. Thankfully, this JavaScript library supports it and can be used right now. There are three steps - create a function signature, construct the transaction, and sign it. After that, it can be sent to the smart contract, and the gas fee can be paid by someone else.</p><h2>Links</h2><ul><li><a href="https://github.com/fassko/meta-transactions">Sample code</a></li></ul><ul><li><a href="https://dev.to/zemse/ethersjs-signing-eip712-typed-structs-2ph8">Ethers.js - Signing EIP712 Typed Structs</a></li><li><a href="https://docs.ethers.org/v5/api/signer/#signers">Ethers.js Signers documentation</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712: Typed structured data hashing and signing standard</a></li></ul></div></div></section></div><footer class="footer"><p>Copyright © Kristaps Grinbergs. 2025.</p><p><a href="https://twitter.com/fassko" target="_blank">Twitter</a>•<a href="/feed.rss">RSS</a>•<a href="/about">Contact</a></p></footer></body></html>