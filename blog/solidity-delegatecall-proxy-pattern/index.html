<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/solidity-delegatecall-proxy-pattern"/><meta name="twitter:url" content="https://kristaps.me/blog/solidity-delegatecall-proxy-pattern"/><meta name="og:url" content="https://kristaps.me/blog/solidity-delegatecall-proxy-pattern"/><title>Mistery revealed about delegatecall in Solidity | Kristaps Grinbergs</title><meta name="twitter:title" content="Mistery revealed about delegatecall in Solidity | Kristaps Grinbergs"/><meta name="og:title" content="Mistery revealed about delegatecall in Solidity | Kristaps Grinbergs"/><meta name="description" content="This time we will talk about the critical lower-level function `delegatecall`. It is widely used in a proxy pattern, for instance, when using [OpenZepplin upgrades pattern](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies). Essentially this function executes code in another contract but uses data from the caller concept. Let's dig deeper and explore more."/><meta name="twitter:description" content="This time we will talk about the critical lower-level function `delegatecall`. It is widely used in a proxy pattern, for instance, when using [OpenZepplin upgrades pattern](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies). Essentially this function executes code in another contract but uses data from the caller concept. Let's dig deeper and explore more."/><meta name="og:description" content="This time we will talk about the critical lower-level function `delegatecall`. It is widely used in a proxy pattern, for instance, when using [OpenZepplin upgrades pattern](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies). Essentially this function executes code in another contract but uses data from the caller concept. Let's dig deeper and explore more."/><meta name="og:site_name" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:title" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="og:image" content="https://kristaps.me/og-image.png"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="og:image:secure_url" content="https://kristaps.me/og-image.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - Blockchain, mobile and fullstack developer. Startup founder. Conference speaker. Mentor. Passionate about building products, sustainability and Web 3.0"/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><script async src="https://www.googletagmanager.com/gtag/js?id=G-HBCE3H3QVL"></script><script src="/scripts/ga.js"></script><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1><a class="blog-title" href="/blog/solidity-delegatecall-proxy-pattern">Mistery revealed about delegatecall in Solidity</a></h1><div class="blog-date"><ul class="blog-tags"><li><a href="/tags/solidity">Solidity</a></li><li><a href="/tags/web3">web3</a></li><li><a href="/tags/proxy">proxy</a></li><li><a href="/tags/delegatecall">delegatecall</a></li></ul>Jul 29, 2022</div><div class="blog-content"><p>This time we will talk about the critical lower-level function <code>delegatecall</code>. It is widely used in a proxy pattern, for instance, when using <a href="https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies">OpenZepplin upgrades pattern</a>. Essentially this function executes code in another contract but uses data from the caller concept. Let's dig deeper and explore more.</p><h2>Storage clash</h2><p>When using <code>delegatecall</code> function, it is vital to note that state variables should be in the same order in both contracts. If it isn't, then bizarre things can happen. For instance, data will be overwritten.</p><h2>Data labyrinth</h2><p>Let's have a contract, <code>Executor</code>, that will save our lucky number, sender address, and Ether value sent to it.</p><pre><code>pragma solidity ^<span class="number">0.8.0</span>;

<span class="keyword">import</span> <span class="string">"hardhat/console.sol"</span>;

contract <span class="type">Executor</span> {
  uint256 <span class="keyword">public</span> luckyNumber;
  address <span class="keyword">public</span> sender;
  uint256 <span class="keyword">public</span> value;

  function <span class="call">setLuckyNumber</span>(uint256 _luckyNumber) <span class="keyword">public</span> payable {
    luckyNumber = _luckyNumber;
    sender = msg.<span class="property">sender</span>;
    value = msg.<span class="property">value</span>;
  }
}
</code></pre><p>Let's deploy the <code>Executor</code> contract and get the deployed address.</p><img src="/assets/solidity-delegatecall/deployed-executor-contract.png" alt="Deployed <code>Executor</code> contract"/><p>After that, we can create the <code>Caller</code> smart contract.</p><img src="/assets//solidity-delegatecall/interact-caller-executor.png" alt="Deploy <code>Caller</code> contract"/><pre><code>contract <span class="type">Caller</span> {
  uint256 <span class="keyword">public</span> luckyNumber;
  address <span class="keyword">public</span> sender;
  uint256 <span class="keyword">public</span> value;

  function <span class="call">setLuckyNumber</span>(address executor, uint256 _luckyNumber) <span class="keyword">public</span> payable {
    (bool success, bytes memory data) = executor.<span class="call">delegatecall</span>(
      abi.<span class="call">encodeWithSignature</span>(<span class="string">"setLuckyNumber(uint256)"</span>, _luckyNumber)
    );

    console.<span class="call">log</span>(success);
  }
}
</code></pre><p>Now when we interact with the <code>Caller</code> contract and set the lucky number, we can see that data has been changed only in this contract, not in the <code>Executor</code> contract. To verify that, we can get the lucky number from both contracts.</p><img src="/assets/solidity-delegatecall/deploy-caller-contract.png" alt="Interaction with the <code>Caller</code> and <code>Executor</code> smart contracts"/><h2>Potential vulnerability</h2><p>Using the <code>delegatecall</code> function is a compelling feature in Solidity programming language. With great power comes great responsibility. It can be perilous when misused.</p><p>Two major vulnerability attacks are mistakes preserving caller context and storage layout mismatch. We won't go into details this time but will follow up on that in future posts.</p><h2>TL;DR</h2><p>The <code>delegatecall</code> is a lower-level function in Solidity programming language. It unlocks the possibility to interact from one smart contract with another by using the caller's context. When using <code>delegatecall</code> we should be super careful because misusing it can cause serious vulnerabilities.</p><h2>Links</h2><ul><li><a href="https://gist.github.com/fassko/8af2cca1a71895a03cb28198fe57315f">Sample code</a></li></ul><ul><li><a href="https://docs.soliditylang.org/en/v0.8.15/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries">Official documentation</a></li><li><a href="https://solidity-by-example.org/delegatecall/">Delegatecall - Solidity by Example</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-1967">EIP-1967: Standard Proxy Storage Slots</a></li><li><a href="https://docs.openzeppelin.com/contracts/4.x/upgradeable">OpenZepplin upgrades</a></li><li><a href="https://solidity-by-example.org/hacks/delegatecall/">Delegatecall Vulnerabilities</a></li><li><a href="https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-5-calling-other-contracts-visibility-state-access/topic/delegatecall/">https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-5-calling-other-contracts-visibility-state-access/topic/delegatecall/</a></li><li><a href="https://eip2535diamonds.substack.com/p/understanding-delegatecall-and-how">Understanding delegatecall And How to Use It Safely</a></li></ul></div></div></section></div><footer class="footer"><p>Copyright © Kristaps Grinbergs. 2025.</p><p><a href="https://twitter.com/fassko" target="_blank">Twitter</a>•<a href="/feed.rss">RSS</a>•<a href="/about">Contact</a></p></footer></body></html>