<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/websockets-swift"/><meta name="twitter:url" content="https://kristaps.me/blog/websockets-swift"/><meta name="og:url" content="https://kristaps.me/blog/websockets-swift"/><title>Websockets in iOS using Swift | Kristaps Grinbergs</title><meta name="twitter:title" content="Websockets in iOS using Swift | Kristaps Grinbergs"/><meta name="og:title" content="Websockets in iOS using Swift | Kristaps Grinbergs"/><meta name="description" content="WebSockets allow for extremely fast two-way networking communication, which lets you send and receive updates quicker and more often, not to mention securely. WebSocket is a communication protocol that uses sockets, providing duplex communication over a single TCP connection. It was standardized by the [IETF](https://tools.ietf.org/html/rfc6455) in 2011 and is a different protocol from HTTP."/><meta name="twitter:description" content="WebSockets allow for extremely fast two-way networking communication, which lets you send and receive updates quicker and more often, not to mention securely. WebSocket is a communication protocol that uses sockets, providing duplex communication over a single TCP connection. It was standardized by the [IETF](https://tools.ietf.org/html/rfc6455) in 2011 and is a different protocol from HTTP."/><meta name="og:description" content="WebSockets allow for extremely fast two-way networking communication, which lets you send and receive updates quicker and more often, not to mention securely. WebSocket is a communication protocol that uses sockets, providing duplex communication over a single TCP connection. It was standardized by the [IETF](https://tools.ietf.org/html/rfc6455) in 2011 and is a different protocol from HTTP."/><meta name="og:site_name" content="Kristaps Grinbergs - iOS and Apple technology developer. Startup founder. Conference speaker."/><meta name="og:title" content="Kristaps Grinbergs - iOS and Apple technology developer. Startup founder. Conference speaker."/><meta name="og:description" content="Kristaps Grinbergs - iOS and Apple technology developer. Startup founder. Conference speaker."/><meta name="og:image" content="linkedin.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - iOS and Apple technology developer. Startup founder. Conference speaker."/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1 class="blog-title">Websockets in iOS using Swift</h1><div class="blog-date">5 Jan 2019</div><div class="blog-content"><p>WebSockets allow for extremely fast two-way networking communication, which lets you send and receive updates quicker and more often, not to mention securely. WebSocket is a communication protocol that uses sockets, providing duplex communication over a single TCP connection. It was standardized by the <a href="https://tools.ietf.org/html/rfc6455">IETF</a> in 2011 and is a different protocol from HTTP.</p><p>WebSockets are widely used in chat apps, streaming real-time notifications, and stock prices.</p><h2>Websocket lifecycle</h2><h3>Shaking hands with the server</h3><p>The <a href="https://tools.ietf.org/html/rfc6455#section-4">handshake</a> app is the web part in WebSockets. It's the bridge from HTTP to WebSocket. The client sends a pretty standard HTTP GET <a href="https://tools.ietf.org/html/rfc6455#section-4.2.1">request</a> to the server:</p><pre><code class="language-no-highlight">GET /chat HTTP/1.1
Host: example.com:8000
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 1
</code></pre><p>The most interesting thing here is <code>Sec-WebSocket-Key</code> which is needed for security reasons and is generated according to the <a href="http://tools.ietf.org/html/rfc6455#page-7">WebSocket standard</a>.</p><p>The server validates the request and, if everything is fine, sends back an HTTP <a href="https://tools.ietf.org/html/rfc6455#section-4.2.2">response</a>:</p><pre><code class="language-no-highlight">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</code></pre><h3>Exchange the information</h3><p>At any time, the server or client can send data that follows this specific format:</p><img src="/assets/img/websocket-frame-format.png" alt="Websocket Frame Format"/><p>I will not go over each part, but you can find out more in the <a href="https://tools.ietf.org/html/rfc6455#section-5.6">standard</a>.</p><h3>Pings and pongs</h3><p>At any point, the client or server can send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">ping</a>, and other party must send back a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">pong</a>.</p><h3>Closing</h3><p>Connection can be closed by any party via sending a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.1">specified control sequence</a>.</p><h2>Implementing WebSockets in iOS</h2><p>Implementing WebSockets in iOS, macOS, tvOS or watchOS isn’t a trivial task. New <a href="https://developer.apple.com/documentation/network">Network.framework</a> can simplify that but you still need to deal with underlying tasks like upgrading connection and setting up a WebSocket frame.</p><h3>Starscream</h3><p>The Swift WebSocket client library <a href="https://github.com/daltoniam/Starscream">Startscream</a> simplifies all the heavy-lifting tasks. Install the library and import it in any Swift file.</p><pre><code><span class="keyword">import</span> Starscream
</code></pre><h3>Creating the connection</h3><p>After that, create a connection and set up the delegate.</p><pre><code><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"ws://echo.websocket.org"</span>)!
<span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: url)
<span class="keyword">let</span> websocket = <span class="type">WebSocket</span>(request: request)
</code></pre><h3>Setting up delegation</h3><p>Then we need to set up delegate and implement <code>didReceive</code> method with event <code>WebSocketEvent</code> type.</p><pre><code><span class="keyword">func</span> didReceive(event: <span class="type">WebSocketEvent</span>, client: <span class="type">WebSocket</span>) {
  <span class="keyword">switch</span> event {
  <span class="keyword">case</span> .<span class="dotAccess">connected</span>(<span class="keyword">let</span> headers):
    <span class="call">print</span>(<span class="string">"connected</span> \(headers)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">disconnected</span>(<span class="keyword">let</span> reason, <span class="keyword">let</span> closeCode):
    <span class="call">print</span>(<span class="string">"disconnected</span> \(reason) \(closeCode)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">text</span>(<span class="keyword">let</span> text):
    <span class="call">print</span>(<span class="string">"received text:</span> \(text)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">binary</span>(<span class="keyword">let</span> data):
    <span class="call">print</span>(<span class="string">"received data:</span> \(data)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">pong</span>(<span class="keyword">let</span> pongData):
    <span class="call">print</span>(<span class="string">"received pong:</span> \(pongData)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">ping</span>(<span class="keyword">let</span> pingData):
    <span class="call">print</span>(<span class="string">"received ping:</span> \(pingData)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">error</span>(<span class="keyword">let</span> error):
    <span class="call">print</span>(<span class="string">"error</span> \(error)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">viabilityChanged</span>:
    <span class="call">print</span>(<span class="string">"viabilityChanged"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">reconnectSuggested</span>:
    <span class="call">print</span>(<span class="string">"reconnectSuggested"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">cancelled</span>:
    <span class="call">print</span>(<span class="string">"cancelled"</span>)
  }
}
</code></pre><p>Once this is done, we can start the connection. Making the handshake and upgrading connection is done behind the scenes by the library.</p><pre><code>socket.<span class="call">connect</span>();
</code></pre><h3>Sending data</h3><p>There are several ways to send data:</p><ul><li>binary</li><li>string</li><li>ping</li><li>pong</li></ul><p>The easiest way is to just send a string:</p><pre><code>socket.<span class="call">write</span>(string: <span class="string">"Hi Server!"</span>)
</code></pre><h3>Closing the connection</h3><p>At any point, we can check close it if it’s not needed anymore.</p><pre><code>websocket.<span class="call">disconnect</span>(closeCode: <span class="type">CloseCode</span>.<span class="property">goingAway</span>.<span class="property">rawValue</span>)
</code></pre><h2>TL;DR</h2><p>WebSocket isn’t a first-class citizen in iOS, macOS, tvOS and watchOS. It can be quite overwhelming to implement, use and understand it, but the Swift library Starscream can help you take care of all these tasks.</p><h2>Links</h2><ul><li><a href="https://tools.ietf.org/html/rfc6455">The WebSocket Protocol</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">Writing WebSocket servers</a></li><li><a href="https://github.com/daltoniam/Starscream">Starscream Swift WebSocket library</a></li><li><a href="https://github.com/ZewoGraveyard/WebSocket/blob/master/Sources/WebSocket/Frame.swift">Websocket Frame implementation in Swift</a></li><li><a href="http://lucumr.pocoo.org/2012/9/24/websockets-101/">WebSockets 101</a></li><li><a href="https://devcenter.heroku.com/articles/websocket-security">WebSocket Security</a></li></ul></div></div></section></div><footer class="footer">Copyright © Kristaps Grinbergs. 2020</footer></body></html>