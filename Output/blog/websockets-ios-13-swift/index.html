<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Kristaps Grinbergs"/><link rel="canonical" href="https://kristaps.me/blog/websockets-ios-13-swift"/><meta name="twitter:url" content="https://kristaps.me/blog/websockets-ios-13-swift"/><meta name="og:url" content="https://kristaps.me/blog/websockets-ios-13-swift"/><title>Websockets in iOS 13 using Swift and Xcode 11 | Kristaps Grinbergs</title><meta name="twitter:title" content="Websockets in iOS 13 using Swift and Xcode 11 | Kristaps Grinbergs"/><meta name="og:title" content="Websockets in iOS 13 using Swift and Xcode 11 | Kristaps Grinbergs"/><meta name="description" content="Websockets in iOS 13, macOS 10.15, tvOS 13, watchOS 6 and Mac Catalyst have gained first-class citizen status in networking stack. Apple has finally added support in [URLSession](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) and for lower level in [Network.framework](https://developer.apple.com/documentation/network/nwprotocolwebsocket) for their platforms. This time we will focus on implementing Websockets using URLSession capabilities."/><meta name="twitter:description" content="Websockets in iOS 13, macOS 10.15, tvOS 13, watchOS 6 and Mac Catalyst have gained first-class citizen status in networking stack. Apple has finally added support in [URLSession](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) and for lower level in [Network.framework](https://developer.apple.com/documentation/network/nwprotocolwebsocket) for their platforms. This time we will focus on implementing Websockets using URLSession capabilities."/><meta name="og:description" content="Websockets in iOS 13, macOS 10.15, tvOS 13, watchOS 6 and Mac Catalyst have gained first-class citizen status in networking stack. Apple has finally added support in [URLSession](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) and for lower level in [Network.framework](https://developer.apple.com/documentation/network/nwprotocolwebsocket) for their platforms. This time we will focus on implementing Websockets using URLSession capabilities."/><meta name="og:site_name" content="Kristaps Grinbergs - iOS and Apple technology developer. Startup founder. Conference speaker."/><meta name="og:title" content="Kristaps Grinbergs - iOS and Apple technology developer. Startup founder. Conference speaker."/><meta name="og:description" content="Kristaps Grinbergs - iOS and Apple technology developer. Startup founder. Conference speaker."/><meta name="og:image" content="linkedin.png"/><meta name="og:type" content="website"/><meta name="og:url" content="https://kristaps.me"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@fassko"/><meta name="twitter:title" content="Kristaps Grinbergs"/><meta name="twitter:description" content="Kristaps Grinbergs - iOS and Apple technology developer. Startup founder. Conference speaker."/><meta name="twitter:image" content="fb-og.png"/><link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"/><link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Kristaps Grinbergs"/></head><body><header class="header"><div class="header-wrapper"><div class="main-title"><a href="/">Kristaps Grinbergs</a></div><nav class="nav-container"><nav><ul class="nav"><li class="nav-item"><a href="/">home</a></li><li class="nav-item"><a href="/blog">blog</a></li><li class="nav-item"><a href="/talks">talks</a></li><li class="nav-item"><a href="/about">about</a></li></ul></nav></nav></div></header><div class="wrapper"><section class="blog-list"><div class="blog-item"><h1 class="blog-title">Websockets in iOS 13 using Swift and Xcode 11</h1><div class="blog-date">24 Jul 2019</div><div class="blog-content"><p>Websockets in iOS 13, macOS 10.15, tvOS 13, watchOS 6 and Mac Catalyst have gained first-class citizen status in networking stack. Apple has finally added support in <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask">URLSession</a> and for lower level in <a href="https://developer.apple.com/documentation/network/nwprotocolwebsocket">Network.framework</a> for their platforms.</p><p>This time we will focus on implementing Websockets using URLSession capabilities.</p><h2>Before iOS 13</h2><p>Previosly if you wanted to use Websockets in Apple platforms you had to rely on <a href="https://developer.apple.com/documentation/cfnetwork">CFNetwork</a> which was added in iOS 2.0. It is using C based foundation streams. You then have to deal with pointers and memory allocation issues which is quite common in C language.</p><p>Another way was to use third party solutions like <a href="https://github.com/daltoniam/Starscream">Starscream</a> which I have <a href="/websockets-swift/">described before</a>.</p><h2>Websockets using URLSession</h2><p>Here are three ways how you can construct a Websocket using <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask">URLSessionWebSocketTask</a> class provided by <a href="https://developer.apple.com/documentation/foundation/urlsession">URLSession</a>:</p><pre><code><span class="keyword">func</span> webSocketTask(with: <span class="type">URL</span>) -&gt; <span class="type">URLSessionWebSocketTask</span>
<span class="keyword">func</span> webSocketTask(with: <span class="type">URLRequest</span>) -&gt; <span class="type">URLSessionWebSocketTask</span>
<span class="keyword">func</span> webSocketTask(with: <span class="type">URL</span>, protocols: [<span class="type">String</span>]) -&gt; <span class="type">URLSessionWebSocketTask</span>
</code></pre><h3>Opening connection</h3><p>To create and open Websocket connection:</p><pre><code><span class="keyword">let</span> urlSession = <span class="type">URLSession</span>(configuration: .<span class="dotAccess">default</span>)
<span class="keyword">let</span> webSocketTask = urlSession.<span class="call">webSocketTask</span>(with: <span class="string">"wss://echo.websocket.org"</span>)
webSocketTask.<span class="call">resume</span>()
</code></pre><h3>Sending messages</h3><p>When connection has been established you can send <code>Data</code> or <code>String</code> message using <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3281790-send">URLSessionWebSocketTask.send</a> function. You need to construct message with <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/message">URLSessionWebSocketTask.Message</a> enum type.</p><pre><code><span class="keyword">let</span> message = <span class="type">URLSessionWebSocketTask</span>.<span class="type">Message</span>.<span class="call">string</span>(<span class="string">"Hello World"</span>)
webSocketTask.<span class="call">send</span>(message) { error <span class="keyword">in
  if let</span> error = error {                
    <span class="call">print</span>(<span class="string">"WebSocket couldn’t send message because:</span> \(error)<span class="string">"</span>)
  }
}
</code></pre><h3>Receiving messages</h3><p>To receive messages from the server you need to use <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3281789-receive">URLSessionWebSocketTask.receive</a> method. It accepts completion handler which is a <a href="https://developer.apple.com/documentation/swift/result">Result</a> of <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/message">Message</a> type.</p><pre><code>webSocketTask.<span class="call">receive</span> { result <span class="keyword">in
  switch</span> result {
  <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
    <span class="call">print</span>(<span class="string">"Error in receiving message:</span> \(error)<span class="string">"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> message):
    <span class="keyword">switch</span> message {
    <span class="keyword">case</span> .<span class="dotAccess">string</span>(<span class="keyword">let</span> text):
      <span class="call">print</span>(<span class="string">"Received string:</span> \(text)<span class="string">"</span>)
    <span class="keyword">case</span> .<span class="dotAccess">data</span>(<span class="keyword">let</span> data):
      <span class="call">print</span>(<span class="string">"Received data:</span> \(data)<span class="string">"</span>)
    }
  }
}
</code></pre><p>Be aware that if you want to receive messages continuously you need to call this again once you are done with receiving a message. One way is to wrap this in a function and call the same function recursively.</p><pre><code><span class="keyword">func</span> receiveMessage() {
  webSocketTask.<span class="call">receive</span> { result <span class="keyword">in
    switch</span> result {
    <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
      <span class="call">print</span>(<span class="string">"Error in receiving message:</span> \(error)<span class="string">"</span>)
    <span class="keyword">case</span> .<span class="dotAccess">success</span>(<span class="keyword">let</span> message):
      <span class="keyword">switch</span> message {
      <span class="keyword">case</span> .<span class="dotAccess">string</span>(<span class="keyword">let</span> text):
        <span class="call">print</span>(<span class="string">"Received string:</span> \(text)<span class="string">"</span>)
      <span class="keyword">case</span> .<span class="dotAccess">data</span>(<span class="keyword">let</span> data):
        <span class="call">print</span>(<span class="string">"Received data:</span> \(data)<span class="string">"</span>)
      }
      
      <span class="keyword">self</span>.<span class="call">receiveMessage</span>()                
    }
  }	
}
</code></pre><h3>Pings and pongs</h3><p>To keep connection active with the server it is a good approach to send PING message with an interval. You can achieve that with <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/3181206-sendping">URLSessionWebSocketTask.sendPing</a> function.</p><pre><code><span class="keyword">func</span> sendPing() {
  webSocketTask.<span class="call">sendPing</span> { (error) <span class="keyword">in
    if let</span> error = error {
      <span class="call">print</span>(<span class="string">"Sending PING failed:</span> \(error)<span class="string">"</span>)
    }

    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: .<span class="call">now</span>() + <span class="number">10</span>) {
      <span class="keyword">self</span>.<span class="call">sendPing</span>()
    }
  }
}
</code></pre><p>Here again you need to take care of the next PING sending yourself. Easiest way is to just use DispatchQueue or Timer functionality.</p><h3>Close connection</h3><p>Once you’re done and would like to close the Websocket connection you need to send a close code which is a <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/closecode">URLSessionWebSocketTask.CloseCode</a> enum type.</p><pre><code>webSocketTask.<span class="call">cancel</span>(closeCode: .<span class="dotAccess">goingAway</span>, reason: <span class="keyword">nil</span>)
</code></pre><h3>Checking connection state</h3><p>To monitor connection status you can use <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsocketdelegate">URLSessionWebSocketDelegate</a> protocol. You can check once connection has been opened or closed.</p><pre><code><span class="comment">/// connection disconnected</span>
<span class="keyword">func</span> urlSession(<span class="keyword">_</span> session: <span class="type">URLSession</span>, 
                webSocketTask: <span class="type">URLSessionWebSocketTask</span>,
                didCloseWith closeCode: <span class="type">URLSessionWebSocketTask</span>.<span class="type">CloseCode</span>,
                reason: <span class="type">Data</span>?)

<span class="comment">// connection established</span>
<span class="keyword">func</span> urlSession(<span class="keyword">_</span> session: <span class="type">URLSession</span>,
                webSocketTask: <span class="type">URLSessionWebSocketTask</span>,
                didOpenWithProtocol protocol: <span class="type">String</span>?)
</code></pre><h2>TL;DR</h2><p>Apple has finally added Websockets as first-class citzen to its platforms. Of course there are small quirks and rough edges. For instance, you can’t receive messages continously, but you don’t need to mess with constructing Websocket frame anymore which is a big win.</p><p>Right now it is available only for latest betas and if you support older versions of iOS, tvOS, watchOS or macOS you need to think about backwards compatibility yourself.</p><h2>Links</h2><ul><li><a href="https://developer.apple.com/documentation/foundation">URLsession documentation</a></li><li><a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask">URLSessionWebSocketTask documentation</a></li><li><a href="https://developer.apple.com/documentation/foundation/urlsessionwebsocketdelegate">URLSessionWebSocketDelegate documentation</a></li><li><a href="https://appspector.com/blog/websockets-in-ios-using-urlsessionwebsockettask">Blogpost by AppSpector</a></li><li><a href="/websockets-swift/">My previous blogpost about using Websockets</a></li></ul></div></div></section></div><footer class="footer">Copyright © Kristaps Grinbergs. 2020</footer></body></html>